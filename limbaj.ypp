%{
#include <stdio.h>
#include <stdarg.h>
#include "types.h"

//	#define DEBUG_MODE

extern FILE* yyin;
extern char* yytext;
extern int yylineno;
int yyerror(const char* s);
int yyfmterror(const char* fmt, ...);
int yylex(void);
void leave();

/* IMPORTANT VARIABLES */
std::stack<std::string> currentScope;
std::map<std::string, Language::Variable*> variables;
std::map<std::string, Language::Type> actualTypes;

/*
void make_variable(char* type, char* name, void* value = NULL) 
{
	std::string tempName = currentScope.top() + name;
	if (variables.find(tempName) != variables.end())
	{
		yyerror("Two variables with the same name in the same scope");
	}
	
	Language::Variable* newVar = new Language::Variable;
	Language::Type actualT = actualTypes[std::string(type)];
	newVar->type = actualT;
	newVar->name = name;
	newVar->scope = currentScope.top();

	#ifdef DEBUG_MODE
		printf("Variable:\n  TYPE: %s\n  NAME: %s\n", type, name);
	#endif
	if (actualT == Language::Type::STR)
	{
		if (value != NULL) 
		{
			newVar->value.str_val = strdup((char*)value);
		}
		else 
		{
			newVar->value.str_val = "";
		}
		
		#ifdef DEBUG_MODE
			printf("  VALUE: %s\n", newVar->value.str_val);
		#endif
	}
	else if (actualT == Language::Type::INT)
	{
		if (value != NULL) 
		{
			newVar->value.int_val = *(int*)(value);
		}
		else 
		{
			newVar->value.int_val = 0;
		}
		
		#ifdef DEBUG_MODE
			printf("  VALUE: %d\n", newVar->value.int_val);
		#endif
	}
	else if (actualT == Language::Type::BOOLEAN)
	{
		if (value != NULL) 
		{
			newVar->value.bool_val = *(bool*)(value);
		}
		else 
		{
			newVar->value.bool_val = false;
		}
		
		#ifdef DEBUG_MODE
			printf("  VALUE: %d\n", newVar->value.bool_val);
		#endif
	}
	variables[newVar->scope + newVar->name] = newVar;
}
*/

%}

%union {
	int intvalue;
	bool boolvalue;
	char* strvalue;	
	Language::Type typevalue;
	Language::Value exprvalue;
}


%token <strvalue>ID TELLING FIXED
%token INT_TYPE STR_TYPE BOOLEAN_TYPE
%token <intvalue>NUMBER <strvalue>STRING <boolvalue>BOOL_TRUE <boolvalue>BOOL_FALSE
%token QUOTE 
%token ENTER LET BE THERE EQUALLING UPON ADDED ASCEND DESCEND CRY FOR DIVIDED REMINDING ADDING CONSPIRING EMPOWERING IS LEFT RIGHT COMMA UP TO DOWN LOWER GREATER THAN EXEUNT SUMMONED NOT SINCE FROM ASK WHETHER THEN OTHERWISE CHANGES INCREASES DECREASES WHENEVER DOES NONE ONE TWICE UNTRUTH INDEED

%type <typevalue>var_type
%type <exprvalue>expression

%left  ADDING CONSPIRING
%left  EMPOWERING REMINDING DIVIDED

%start progr
%%
progr: 		lines {printf("program corect sintactic\n");}
     		;


lines: 		line
      		| lines line
        	;

line: 		declaration
		| expression
		| output
		;

var_type:	INT_TYPE { $$ = Language::Type::INT; }
		| STR_TYPE { $$ = Language::Type::STR; }
		| BOOLEAN_TYPE { $$ = Language::Type::BOOLEAN; }
		;
	
declaration:	ENTER var_type ID
	        {
			//make_variable($<strvalue>2, $<strvalue>3);
		}
		;

expression: 	'<' expression '>' 
		{ 
			$$ = $2; 
		}
		| expression ADDING expression
		{
			if ($1.type == Language::Type::INT && $3.type == Language::Type::INT)
			{
				$$.type = Language::Type::INT;
				$$.value.int_val = $1.value.int_val + $3.value.int_val;
			}
			else if ($1.type == Language::Type::STR && $3.type == Language::Type::STR) 
			{
				//Unite both strings "hey" + "mate" = "heymate"
				$$.type == $1.type;
				$$.value.str_val = (char*)calloc(strlen($1.value.str_val) + strlen($3.value.str_val) + 1, sizeof(char));
				strncpy($$.value.str_val, $1.value.str_val, strlen($1.value.str_val));
				strncpy($$.value.str_val + strlen($1.value.str_val), $3.value.str_val, strlen($3.value.str_val));
				$$.value.str_val[strlen($1.value.str_val) + strlen($3.value.str_val)] = '\0';	
			}
			else
			{
				yyfmterror("Invalid types for adding");
			}
		}
		| expression CONSPIRING expression 
		{
			if ($1.type == Language::Type::INT && $3.type == Language::Type::INT)
			{
				$$.type == Language::Type::INT;
				$$.value.int_val = $1.value.int_val - $3.value.int_val;
			}
			else
			{
				yyfmterror("Invalid types for conspiring");
			}
		}
		| expression DIVIDED expression
		{
			if ($1.type == Language::Type::INT && $3.type == Language::Type::INT) 
			{
				$$.type == Language::Type::INT;
				$$.value.int_val = $1.value.int_val / $3.value.int_val;
			}
			else
			{
				yyfmterror("Invalid types for dividing");
			}			
		}
		| expression REMINDING expression
		{
			if ($1.type == Language::Type::INT && $3.type == Language::Type::INT) 
			{
				$$.type == Language::Type::INT;
				$$.value.int_val = $1.value.int_val % $3.value.int_val;
			}
			else
			{
				yyfmterror("Invalid types for reminding");
			}		
		}
		| expression EMPOWERING expression 
		{
			if ($1.type == Language::Type::INT && $3.type == Language::Type::INT)
			{
				$$.type == Language::Type::INT;
				$$.value.int_val = $1.value.int_val * $3.value.int_val;
			}
			else if (($1.type == Language::Type::INT && $3.type == Language::Type::STR)
				||($1.type == Language::Type::STR && $3.type == Language::Type::INT))
			{
				$$.type = Language::Type::STR;
				int slen = 0;
				int ival = 0;
				char* sval = NULL;
				if ($1.type == Language::Type::STR) { sval = $1.value.str_val; slen = strlen(sval); ival = $3.value.int_val; }
				else if ($1.type == Language::Type::INT) { sval = $3.value.str_val; slen = strlen(sval); ival = $1.value.int_val; }
				
				$$.value.str_val = (char*)calloc(slen * ival + 1, sizeof(char));
				for (int i = 0; i < slen * ival; i++)
				{
					$$.value.str_val[i] = sval[i % slen];
				}	
			}
			else 
			{
				yyfmterror("Invalid types for empowering");
			}
		}
	     	| NUMBER 
		{ 
			$$.type = Language::Type::INT; $$.value.int_val = $<intvalue>1; 
			#ifdef DEBUG_MODE
				printf("Expr type: INT, value: %d\n", $$.value.int_val);
			#endif
		}
		| STRING 
		{ 
			$$.type = Language::Type::STR; $$.value.str_val = $<strvalue>1; 
			$$.value.str_val[strlen($$.value.str_val) - 1 ] = '\0';
			$$.value.str_val++;
			#ifdef DEBUG_MODE
				printf("Expr type: STR, value: %s\n", $$.value.str_val);
			#endif
		}
		| BOOL_FALSE 
		{ 
			$$.type = Language::Type::BOOLEAN; $$.value.bool_val = false; 
			#ifdef DEBUG_MODE
				printf("Expr type: BOOL, value: %d\n", $$.value.bool_val);
			#endif
		}
		| BOOL_TRUE 
		{ 
			$$.type = Language::Type::BOOLEAN; $$.value.bool_val = true; 
			#ifdef DEBUG_MODE
				printf("Expr type: BOOL, value: %d\n", $$.value.bool_val);
			#endif
		}
		;

output:		QUOTE expression  
		{ 
			if ($2.type == Language::Type::STR) printf("[QUOTE] %s\n", $2.value.str_val);
			if ($2.type == Language::Type::INT) printf("[QUOTE] %d\n", $2.value.int_val);
			if ($2.type == Language::Type::BOOLEAN) printf("[QUOTE] %s\n", ($2.value.bool_val == true) ? "true" : "false");			
		}
		;


%%
void leave()
{
	for (auto var : variables)
	{
		delete var.second;		
	}
	exit(-1);
}

int yyfmterror(const char* fmt, ...)
{
	char str[200];
	va_list args;
	va_start(args, fmt);
	vsprintf(str, fmt, args);
	yyerror(str);
}

int yyerror(const char* s)
{
	printf("Error: %s on line: %d\n",s,yylineno);
	leave();
}

int main(int argc, char** argv){
	currentScope.push("$main");
	actualTypes["whole"] = Language::Type::INT;
	actualTypes["full"] = Language::Type::INT;
	actualTypes["fixed"] = Language::Type::INT;
	actualTypes["doubting"] = Language::Type::BOOLEAN;
	actualTypes["discrete"] = Language::Type::INT;
	actualTypes["saying"] = Language::Type::STR;
	yyin=fopen(argv[1],"r");
	yyparse();
	return 0;
} 
