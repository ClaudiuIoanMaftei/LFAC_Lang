%{
#include <stdio.h>
#include <stdarg.h>
#include "types.h"

//#define DEBUG_MODE

extern FILE* yyin;
extern char* yytext;
extern int yylineno;
int yyerror(const char* s);
int yyfmterror(const char* fmt, ...);
int yylex(void);
void leave();

/* IMPORTANT VARIABLES */
std::stack<std::string> currentScope;
std::map<std::string, Language::Variable*> variables;
std::map<std::string, Language::Type> actualTypes;

/*
void make_variable(char* type, char* name, void* value = NULL) 
{
	std::string tempName = currentScope.top() + name;
	if (variables.find(tempName) != variables.end())
	{
		yyerror("Two variables with the same name in the same scope");
	}
	
	Language::Variable* newVar = new Language::Variable;
	Language::Type actualT = actualTypes[std::string(type)];
	newVar->type = actualT;
	newVar->name = name;
	newVar->scope = currentScope.top();

	#ifdef DEBUG_MODE
		printf("Variable:\n  TYPE: %s\n  NAME: %s\n", type, name);
	#endif
	if (actualT == Language::Type::STR)
	{
		if (value != NULL) 
		{
			newVar->value.str_val = strdup((char*)value);
		}
		else 
		{
			newVar->value.str_val = "";
		}
		
		#ifdef DEBUG_MODE
			printf("  VALUE: %s\n", newVar->value.str_val);
		#endif
	}
	else if (actualT == Language::Type::INT)
	{
		if (value != NULL) 
		{
			newVar->value.int_val = *(int*)(value);
		}
		else 
		{
			newVar->value.int_val = 0;
		}
		
		#ifdef DEBUG_MODE
			printf("  VALUE: %d\n", newVar->value.int_val);
		#endif
	}
	else if (actualT == Language::Type::BOOLEAN)
	{
		if (value != NULL) 
		{
			newVar->value.bool_val = *(bool*)(value);
		}
		else 
		{
			newVar->value.bool_val = false;
		}
		
		#ifdef DEBUG_MODE
			printf("  VALUE: %d\n", newVar->value.bool_val);
		#endif
	}
	variables[newVar->scope + newVar->name] = newVar;
}
*/

%}

%union {
	int intvalue;
	bool boolvalue;
	char* strvalue;	
	Language::Type typevalue;
	Language::Value exprvalue;
}


%token <strvalue>ID TELLING FIXED
%token INT_TYPE STR_TYPE BOOLEAN_TYPE
%token <intvalue>NUMBER <strvalue>STRING <boolvalue>BOOL_TRUE <boolvalue>BOOL_FALSE
%token QUOTE 
%token ENTER LET BE THERE EQUALLING UPON ADDED ASCEND DESCEND CRY FOR DIVIDED REMINDING ADDING CONSPIRING EMPOWERING IS LEFT RIGHT COMMA UP TO DOWN LOWER GREATER THAN EXEUNT SUMMONED NOT SINCE FROM ASK WHETHER THEN OTHERWISE CHANGES INCREASES DECREASES WHENEVER DOES NONE ONE TWICE UNTRUTH INDEED

%type <typevalue>var_type
%type <exprvalue>expression

%left  ADDING CONSPIRING
%left  EMPOWERING REMINDING DIVIDED

%start progr
%%
progr: lines {printf("program corect sintactic\n");}
     ;
lines: 		line
      		| lines line
        	;

line: 		declaration
		| expression
		| output
		;

var_type:	INT_TYPE { $$ = Language::Type::INT; }
		| STR_TYPE { $$ = Language::Type::STR; }
		| BOOLEAN_TYPE { $$ = Language::Type::BOOLEAN; }
		;
	
declaration:	ENTER var_type ID
	        {
			//make_variable($<strvalue>2, $<strvalue>3);
		}
		;

expression: 	'<' expression '>' { $$ = $2; }
		| expression ADDING expression
		{
			if ($1.type == $3.type)
			{
				
				if ($1.type == Language::Type::BOOLEAN) 
				{
					yyfmterror("Can't add with this type");
				}
				else if ($1.type == Language::Type::STR && $3.type == Language::Type::STR)
				{
					$$.type == $1.type;
					$$.value.str_val = (char*)calloc(strlen($1.value.str_val) + strlen($3.value.str_val) + 1, sizeof(char));
					strncpy($$.value.str_val, $1.value.str_val, strlen($1.value.str_val));
					strncpy($$.value.str_val + strlen($1.value.str_val), $3.value.str_val, strlen($3.value.str_val));
					$$.value.str_val[strlen($1.value.str_val) + strlen($3.value.str_val)] = '\0';
				}
			}
			else
			{
				yyfmterror("Invalid types for adding");
			}	
		}
		| expression DIVIDED expression
		{
			if ($1.type == $3.type)
			{
				
				if ($1.type == Language::Type::STR || $1.type == Language::Type::BOOLEAN) 
				{
					yyfmterror("Can't divide with this type");
				}
				else 
				{
					$$.type == $1.type;
					$$.value.int_val = $1.value.int_val / $3.value.int_val;
				}
			}
			else
			{
				yyfmterror("Invalid types for dividing");
			}			
		}
		| expression REMINDING expression
		{
			if ($1.type == $3.type)
			{
				
				if ($1.type == Language::Type::STR || $1.type == Language::Type::BOOLEAN) 
				{
					yyfmterror("Can't remind of this type");
				}
				else 
				{
					$$.type == $1.type;
					$$.value.int_val = $1.value.int_val % $3.value.int_val;
				}
			}
			else
			{
				yyfmterror("Invalid types for reminding");
			}			
		}
		| expression CONSPIRING expression 
		{
			if ($1.type == $3.type)
			{
				
				if ($1.type == Language::Type::STR || $1.type == Language::Type::BOOLEAN) 
				{
					yyfmterror("Can't conspire on this type");
				}
				else 
				{
					$$.type == $1.type;
					$$.value.int_val = $1.value.int_val - $3.value.int_val;
				}
			}
			else
			{
				yyfmterror("Invalid types for conspiring");
			}
		}
		| expression EMPOWERING expression 
		{
			if ($1.type == $3.type)
			{
				
				if ($1.type == Language::Type::STR || $1.type == Language::Type::BOOLEAN) 
				{
					yyfmterror("Can't multiply this type");
				}
				else 
				{
					$$.type == $1.type;
					$$.value.int_val = $1.value.int_val * $3.value.int_val;
				}
			}
			else
			{
				if   (($1.type == Language::Type::STR && $3.type == Language::Type::INT)
				   || ($1.type == Language::Type::INT && $3.type == Language::Type::STR))
				{
					if ($1.type == Language::Type::INT && $3.type == Language::Type::STR) std::swap($1, $3);
					if ($3.value.int_val >= 0)
					{
						$$.type = Language::Type::STR;
						$$.value.str_val = (char*)calloc(strlen($1.value.str_val) * $3.value.int_val + 1, sizeof(char));
						for (int i = 0; i < strlen($1.value.str_val) * $3.value.int_val; i++)
						{
							$$.value.str_val[i] = $1.value.str_val[ i % strlen($1.value.str_val)];
						}
					}
					else 
					{
						yyfmterror("Can't multiply string %s negative times", $1.value.str_val);
					}
				}
				else 
				{
					yyfmterror("Invalid types for multiplication");
				}
			}
		}
	     	| NUMBER 
		{ 
			$$.type = Language::Type::INT; $$.value.int_val = $<intvalue>1; 
			#ifdef DEBUG_MODE
				printf("Expr type: INT, value: %d\n", $$.value.int_val);
			#endif
		}
		| STRING 
		{ 
			$$.type = Language::Type::STR; $$.value.str_val = $<strvalue>1; 
			$$.value.str_val[strlen($$.value.str_val) - 1 ] = '\0';
			$$.value.str_val++;
			#ifdef DEBUG_MODE
				printf("Expr type: STR, value: %s\n", $$.value.str_val);
			#endif
		}
		| BOOL_FALSE 
		{ 
			$$.type = Language::Type::BOOLEAN; $$.value.bool_val = false; 
			#ifdef DEBUG_MODE
				printf("Expr type: BOOL, value: %d\n", $$.value.bool_val);
			#endif
		}
		| BOOL_TRUE 
		{ 
			$$.type = Language::Type::BOOLEAN; $$.value.bool_val = true; 
			#ifdef DEBUG_MODE
				printf("Expr type: BOOL, value: %d\n", $$.value.bool_val);
			#endif
		}
		;

output:		QUOTE expression  
		{ 
			if ($2.type == Language::Type::STR) printf("[QUOTE] %s\n", $2.value.str_val);
			if ($2.type == Language::Type::INT) printf("[QUOTE] %d\n", $2.value.int_val);
			if ($2.type == Language::Type::BOOLEAN) printf("[QUOTE] %s\n", ($2.value.bool_val == true) ? "true" : "false");			
		} 
		| QUOTE ID
		;


%%
void leave()
{
	for (auto var : variables)
	{
		delete var.second;		
	}
	exit(-1);
}

int yyfmterror(const char* fmt, ...)
{
	char str[200];
	va_list args;
	va_start(args, fmt);
	vsprintf(str, fmt, args);
	yyerror(str);
}

int yyerror(const char* s)
{
	printf("Error: %s on line: %d\n",s,yylineno);
	leave();
}

int main(int argc, char** argv){
	currentScope.push("$main");
	actualTypes["whole"] = Language::Type::INT;
	actualTypes["full"] = Language::Type::INT;
	actualTypes["fixed"] = Language::Type::INT;
	actualTypes["doubting"] = Language::Type::BOOLEAN;
	actualTypes["discrete"] = Language::Type::INT;
	actualTypes["saying"] = Language::Type::STR;
	yyin=fopen(argv[1],"r");
	yyparse();
	return 0;
} 
