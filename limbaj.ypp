%{
#include <stdio.h>

#include "types.h"
#include "code.h"
#define YYDEBUG 1

extern FILE* yyin;
extern char* yytext;
extern int yylineno;
int yylex(void);

%}

%union {
	int* intvalue;
	bool* boolvalue;
	std::string* strvalue;
	Language::Value* exprptrvalue;
	Language::Variable* varptrvalue;
	std::vector<Language::Variable*>* decllist;
}

%token ENTER PROCLAIM LET THERE EQUALLING UPON ADDED ASCEND DESCEND CRY FOR DIVIDED REMINDING ADDING CONSPIRING EMPOWERING EXEUNT NOT SINCE FROM ASK WHETHER THEN OTHERWISE CHANGES INCREASES DECREASES WHENEVER DOES NONE ONE TWICE 

%token <strvalue>ID TELLING FIXED
%token INT_TYPE STR_TYPE BOOLEAN_TYPE
%token <intvalue>NUMBER <strvalue>STRING <boolvalue>BOOL_TRUE <boolvalue>BOOL_FALSE
%token QUOTE SUMMON
%token BOOL_IS BOOL_UP BOOL_TO BOOL_DOWN BOOL_LOWER BOOL_GREATER BOOL_THAN

%type <strvalue>var_type
%type <varptrvalue>expression
%type <varptrvalue>predef_func
%type <varptrvalue>output
%type <varptrvalue>input
%type <decllist>decl_list
%type <varptrvalue>declaration
%type <varptrvalue>complex_identifier

%left  ADDING CONSPIRING
%left  EMPOWERING REMINDING DIVIDED
%nonassoc BOOL_IS BOOL_UP BOOL_TO BOOL_DOWN BOOL_LOWER BOOL_GREATER BOOL_THAN NOT

%start programm

%%
programm: 
	statements {printf("program corect sintactic\n");}
	;


statements: 
	statement
	| statements statement
	;


statement: 
	expression
	| if_statement
	| declaration
	| struct_decl
	| assign
	;

complex_identifier:
	ID 
	{
		$$ = get_var(STR($1), NULL);
	}
	| ID FROM complex_identifier 
	{
		$$ = get_var(STR($1), $3);
	}
	;


var_type: 
	INT_TYPE 
	{ 
		$$ = make_type("$INT"); 
	}
	| STR_TYPE 
	{ 
		$$ = make_type("$STR"); 
	}
	| BOOLEAN_TYPE 
	{ 
		$$ = make_type("$BOOL"); 
	}
	| ID 
	{ 
		$$ = make_type(STR($1)); 
	}
	;


assign:
	LET complex_identifier expression
	{
		make_assign($2, $3);
	}
	;

declaration:	
	ENTER var_type ID
	{
		$$ = make_variable(STR($2), STR($3), false, NULL);	
	}
	| ENTER FIXED var_type ID
	{
		$$ = make_variable(STR($2), STR($3), true, NULL);	
	}
	| ENTER var_type ID TELLING expression
	{
		$$ = make_variable(STR($2), STR($3), false, $5);	
	}
	| ENTER FIXED var_type ID TELLING expression
	{
		$$ = make_variable(STR($3), STR($4), true, $6);	
	}
	;



decl_list:
	declaration
	{
		$$ = make_list($1, NULL);
	}
	| decl_list ',' declaration
	{
		$$ = make_list($3, $1);
	}
	;



struct_decl:	
	PROCLAIM ID '<' decl_list '>'
	{
		make_struct(STR($2), $4);
	}
	;

if_statement:
	ASK WHETHER '<' expression '>' THEN '<' statements '>'  
	{
		make_if($4);
	}
	| ASK WHETHER '<' expression '>' THEN '<' statements '>' OTHERWISE '<' statements '>'
	{
		make_if($4);
	}
	;

expression:
	'<' expression '>' 
	{ 
		$$ = $2; 
	}
	| expression ADDING expression
	{
		$$ = make_addition($1, $3);
	}
	| expression CONSPIRING expression 
	{
		$$ = make_substraction($1, $3);
	}
	| expression DIVIDED expression
	{
		$$ = make_division($1, $3);		
	}
	| expression REMINDING expression
	{
		$$ = make_reminder($1, $3);	
	}
	| expression EMPOWERING expression 
	{
		$$ = make_multiplication($1, $3);
	}
	| expression BOOL_IS expression
	{
		$$ = make_boolean($1, $3, Language::BOOL_OP::EQUAL);
	}
	| expression BOOL_IS NOT expression
	{
		$$ = make_boolean($1, $4, Language::BOOL_OP::NEQUAL);
	}
	| expression BOOL_LOWER BOOL_THAN expression
	{
		$$ = make_boolean($1, $4, Language::BOOL_OP::LOWER);
	}	
	| expression BOOL_GREATER BOOL_THAN expression
	{
		$$ = make_boolean($1, $4, Language::BOOL_OP::GREATER);
	}	
	| expression BOOL_UP BOOL_TO BOOL_LOWER BOOL_THAN expression
	{
		$$ = make_boolean($1, $6, Language::BOOL_OP::LOWEREQ);
	}	
	| expression BOOL_UP BOOL_TO BOOL_GREATER BOOL_THAN expression
	{
		$$ = make_boolean($1, $6, Language::BOOL_OP::GREATEREQ);
	}
	| complex_identifier
	{
		$$ = make_copy($1);
	}
	| NUMBER
	{ 
		$$ = make_expression("$INT", new int(INT($1)));
	}
	| STRING 
	{ 
		$$ = make_expression("$STR", new std::string(STR($1)));
	}
	| BOOL_FALSE 
	{ 
		$$ = make_expression("$BOOL", new bool(BOOL($1)));
	}
	| BOOL_TRUE 
	{ 
		$$ = make_expression("$BOOL", new bool(BOOL($1)));
	}
	| predef_func
	{
		$$ = make_copy($1);
	}
	;

predef_func:
	output
	| input
	;


output:
	QUOTE '<' expression '>' 
	{ 
		$$ = make_print($3);
	}
	;

input:
	SUMMON '<' complex_identifier '>'
	{
		$$ = make_input($3);
	}
	;

%%


int main(int argc, char** argv){
	add_scope("$main");
	yyin=fopen(argv[1],"r");
	yyparse();
	return 0;
} 
