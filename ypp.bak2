%{
#include <stdio.h>
#include <stdarg.h>
#include "types.h"

#define DEBUG_MODE

extern FILE* yyin;
extern char* yytext;
extern int yylineno;
int yyerror(const char* s);
int yyfmterror(const char* fmt, ...);
int yylex(void);
void leave();

/* IMPORTANT VARIABLES */
std::stack<std::string> currentScope;
std::map<std::string, Language::Variable*> variables;
std::map<std::string, Language::Type> actualTypes;

void make_variable(char* type, char* name, void* value = NULL) 
{
	std::string tempName = currentScope.top() + name;
	if (variables.find(tempName) != variables.end())
	{
		yyerror("Two variables with the same name in the same scope");
	}
	
	Language::Variable* newVar = new Language::Variable;
	Language::Type actualT = actualTypes[std::string(type)];
	newVar->type = actualT;
	newVar->name = name;
	newVar->scope = currentScope.top();

	#ifdef DEBUG_MODE
		printf("Variable:\n  TYPE: %s\n  NAME: %s\n", type, name);
	#endif
	if (actualT == Language::Type::STR)
	{
		if (value != NULL) 
		{
			newVar->value.str_val = strdup((char*)value);
		}
		else 
		{
			newVar->value.str_val = "";
		}
		
		#ifdef DEBUG_MODE
			printf("  VALUE: %s\n", newVar->value.str_val);
		#endif
	}
	else if (actualT == Language::Type::INT)
	{
		if (value != NULL) 
		{
			newVar->value.int_val = *(int*)(value);
		}
		else 
		{
			newVar->value.int_val = 0;
		}
		
		#ifdef DEBUG_MODE
			printf("  VALUE: %d\n", newVar->value.int_val);
		#endif
	}
	else if (actualT == Language::Type::BOOLEAN)
	{
		if (value != NULL) 
		{
			newVar->value.bool_val = *(bool*)(value);
		}
		else 
		{
			newVar->value.bool_val = false;
		}
		
		#ifdef DEBUG_MODE
			printf("  VALUE: %d\n", newVar->value.bool_val);
		#endif
	}
	variables[newVar->scope + newVar->name] = newVar;
}

%}

%union {
	int intvalue;
	bool boolvalue;
	char* strvalue;	
	Language::Type typevalue;
}


%token <strvalue>ID TELLING FIXED
%token INT_TYPE STR_TYPE BOOLEAN_TYPE
%token <intvalue>NUMBER <strvalue>STRING <boolvalue>BOOL_TRUE <boolvalue>BOOL_FALSE
%token QUOTE 
%token ENTER LET BE THERE EQUALLING UPON ADDED ASCEND DESCEND CRY FOR DIVIDED REMINDING ADDING CONSPIRING EMPOWERING IS LEFT RIGHT COMMA UP TO DOWN LOWER GREATER THAN EXEUNT SUMMONED NOT SINCE FROM ASK WHETHER THEN OTHERWISE CHANGES INCREASES DECREASES WHENEVER DOES NONE ONE TWICE UNTRUTH INDEED

%type <boolvalue>bool_expr
%type <typevalue>var_type
%type <typevalue>expression

%start progr
%%
progr: lines {printf("program corect sintactic\n");}
     ;
lines: 		line
      		| lines line
        	;

line: 		declaration
		;

var_type:	INT_TYPE { $$ = Langauge::Type::INT; }
		| STR_TYPE { $$ = Langauge::Type::STR; }
		| BOOLEAN_TYPE { $$ = Langauge::Type::BOOLEAN; }
		;
	
declaration:	ENTER var_type ID TELLING expression
		{
			if (actualTypes[std::string($<strvalue>2)] == Language::Type::INT) 
				make_variable($<strvalue>2, $<strvalue>3, (void*)&($<intvalue>5));
			else yyfmterror("A %s type variable needs a int expression", $<strvalue>2);
		}
		| ENTER TYPE ID TELLING expression
	        {
			if (actualTypes[std::string($2)] == Language::Type::STR) 
				make_variable($<strvalue>2, $<strvalue>3, (void*)$<strvalue>5);
			else yyfmterror("A %s type variable needs a string expression", $<strvalue>2);
		}
		| ENTER TYPE ID TELLING expression
	        {
			if (actualTypes[std::string($2)] == Language::Type::BOOLEAN) 
				make_variable($<strvalue>2, $<strvalue>3, (void*)&$<boolvalue>5);
			else yyfmterror("A %s type variable needs a boolean expression", $<boolvalue>2);
		}
		| ENTER TYPE ID
	        {
			make_variable($<strvalue>2, $<strvalue>3);
		}
		;

expression: 	LEFT expression RIGHT { $<intvalue>$ = $<intvalue>2; }
		| expression ADDING expression { $<intvalue>$ = $<intvalue>1 + $<intvalue>3; }
		| expression DIVIDED expression { $<intvalue>$ = $<intvalue>1 / $<intvalue>3; }
		| expression REMINDING expression { $<intvalue>$ = $<intvalue>1 % $<intvalue>3; }
		| expression CONSPIRING expression { $<intvalue>$ = $<intvalue>1 - $<intvalue>3; }
		| expression EMPOWERING expression { $<intvalue>$ = $<intvalue>1 * $<intvalue>3; }
	     	| NUMBER { $<intvalue>$ = $<intvalue>1; }


str_literal: 	STRING ADDING STRING
	    	| STRING EMPOWERING NUMBER	
		| STRING 
		;

math_expr: 	
	     	;

bool_expr:	LEFT bool_expr RIGHT { $<boolvalue>$ = $<boolvalue>2; }
		| bool_expr IS bool_expr { $<boolvalue>$ = ($<boolvalue>1 == $<boolvalue>3); }
		| bool_expr UP TO LOWER THAN bool_expr { $<boolvalue>$ = ($<boolvalue>1 <= $<boolvalue>6); }
		| bool_expr LOWER THAN bool_expr { $<boolvalue>$ = ($<boolvalue>1 < $<boolvalue>4); }
		| bool_expr DOWN TO GREATER THAN bool_expr { $<boolvalue>$ = ($<boolvalue>1 >= $<boolvalue>6); }
		| bool_expr GREATER THAN bool_expr { $<boolvalue>$ = ($<boolvalue>1 > $<boolvalue>4); }
		| bool_expr { $<boolvalue>$ = $<boolvalue>$; }
		| BOOL_TRUE { $<boolvalue>$ = true; }
		| BOOL_FALSE { $<boolvalue>$ = false; }
		;


%%
void leave()
{
	for (auto var : variables)
	{
		delete var.second;		
	}
	exit(-1);
}

int yyfmterror(const char* fmt, ...)
{
	char str[200];
	va_list args;
	va_start(args, fmt);
	vsprintf(str, fmt, args);
	yyerror(str);
}

int yyerror(const char* s)
{
	printf("Error: %s on line: %d\n",s,yylineno);
	leave();
}

int main(int argc, char** argv){
	currentScope.push("$main");
	actualTypes["whole"] = Language::Type::INT;
	actualTypes["full"] = Language::Type::INT;
	actualTypes["fixed"] = Language::Type::INT;
	actualTypes["doubting"] = Language::Type::BOOLEAN;
	actualTypes["discrete"] = Language::Type::INT;
	actualTypes["saying"] = Language::Type::STR;
	yyin=fopen(argv[1],"r");
	yyparse();
	return 0;
} 
